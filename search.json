[{"title":"PMS","url":"/2019/09/22/PMS/","content":"\n## 1 简介\n\n![](PMS.jpg)\n\n","tags":["PMS"]},{"title":"Alarm简介","url":"/2019/09/22/Alarm简介/","content":"\n> 参考链接\n>\n> https://www.jianshu.com/p/32f438a0c239\n>\n> https://juejin.im/post/5c9095dff265da60c76cd327\n>\n> http://chendongqi.me/2017/03/06/AlarmGroup/    AlarmGroup机制\n\n\n\n## 1 介绍\n\nAlarmManager主要是用来设置一些定时执行的任务，比如启动Activity，发送广播等，还可以直接传入回调方法来定时执行，使用方法可以参考DeviceIdleController里面通过Alarm设置DOZE的状态机转化的过程。Android系统通过AlarmManagerService来为管理Alarm，AlarmManager来对外提供操作接口。\n\n**使用示例**\n\n```csharp\nAlarmManager aManager = (AlarmManager)context.getSystemService(Context.ALARM_SERVICE);\n        Intent in = new Intent();\n        in.setClass(context, RebootService.class);\n        PendingIntent pi = PendingIntent.getService(context, 0, in, 0);\n        aManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,24 * 60 * 60 * 1000, pi);\n```\n\n上面的例子是通过alarmmanager来执行一个服务，定时到了就会自动执行RebootService这个服务。\n\n![](1.png)\n\n![1569064049192](C:\\Users\\z\\AppData\\Roaming\\Typora\\typora-user-images\\1569064049192.png)\n\n上面是DeviceIdleController中对Alarm的使用方式，mDeepAlarmListener就是传入的回调，回调方法是onAlarm.\n\n<!-- more -->\n\n## 2  Alarm类型\n\n当然从介绍中知道了Alarm的左右以及部分使用方法，那么这里继续介绍一下设置Alarm时候的类型等。\n\n```\n/**\n * Alarm time in {@link System#currentTimeMillis System.currentTimeMillis()}\n * (wall clock time in UTC), which will wake up the device when\n * it goes off.\n */\npublic static final int RTC_WAKEUP = 0;\n/**\n * Alarm time in {@link System#currentTimeMillis System.currentTimeMillis()}\n * (wall clock time in UTC).  This alarm does not wake the\n * device up; if it goes off while the device is asleep, it will not be\n * delivered until the next time the device wakes up.\n */\npublic static final int RTC = 1;\n/**\n * Alarm time in {@link android.os.SystemClock#elapsedRealtime\n * SystemClock.elapsedRealtime()} (time since boot, including sleep),\n * which will wake up the device when it goes off.\n */\npublic static final int ELAPSED_REALTIME_WAKEUP = 2;\n/**\n * Alarm time in {@link android.os.SystemClock#elapsedRealtime\n * SystemClock.elapsedRealtime()} (time since boot, including sleep).\n * This alarm does not wake the device up; if it goes off while the device\n * is asleep, it will not be delivered until the next time the device\n * wakes up.\n */\npublic static final int ELAPSED_REALTIME = 3;\n/// M: added for powerOffAlarm feature @{\n/**\n * M: This alarm type is used to set an alarm that would be triggered if device\n * is in powerOff state. It is set to trigger POWER_OFF_ALARM_BUFFER_TIME ms earlier\n * than the actual alarm time so that phone is in wakeup state when actual alarm\n * triggers\n */\n/** @hide */\npublic static final int PRE_SCHEDULE_POWER_OFF_ALARM = 7;\n```\n\n```\n/** @hide */\n@UnsupportedAppUsage\npublic static final long WINDOW_EXACT = 0;\n/** @hide */\n@UnsupportedAppUsage\npublic static final long WINDOW_HEURISTIC = -1;\n\n/**\n * Flag for alarms: this is to be a stand-alone alarm, that should not be batched with\n * other alarms.\n * @hide\n */\n@UnsupportedAppUsage\npublic static final int FLAG_STANDALONE = 1<<0;\n\n/**\n * Flag for alarms: this alarm would like to wake the device even if it is idle.  This\n * is, for example, an alarm for an alarm clock.\n * @hide\n */\n@UnsupportedAppUsage\npublic static final int FLAG_WAKE_FROM_IDLE = 1<<1;\n\n/**\n * Flag for alarms: this alarm would like to still execute even if the device is\n * idle.  This won't bring the device out of idle, just allow this specific alarm to\n * run.  Note that this means the actual time this alarm goes off can be inconsistent\n * with the time of non-allow-while-idle alarms (it could go earlier than the time\n * requested by another alarm).\n *\n * @hide\n */\npublic static final int FLAG_ALLOW_WHILE_IDLE = 1<<2;\n\n/**\n * Flag for alarms: same as {@link #FLAG_ALLOW_WHILE_IDLE}, but doesn't have restrictions\n * on how frequently it can be scheduled.  Only available (and automatically applied) to\n * system alarms.\n *\n * @hide\n */\n@UnsupportedAppUsage\npublic static final int FLAG_ALLOW_WHILE_IDLE_UNRESTRICTED = 1<<3;\n\n/**\n * Flag for alarms: this alarm marks the point where we would like to come out of idle\n * mode.  It may be moved by the alarm manager to match the first wake-from-idle alarm.\n * Scheduling an alarm with this flag puts the alarm manager in to idle mode, where it\n * avoids scheduling any further alarms until the marker alarm is executed.\n * @hide\n */\n@UnsupportedAppUsage\npublic static final int FLAG_IDLE_UNTIL = 1<<4;\n```\n\n在使用Alarm的适合可以设置不同的Alarm类型，不同类型的Alarm唤醒的条件不同，比如是否能够在DOZE模式下唤醒，是否能够在sleep模式下唤醒系统等。\n\n## 3 设置Alarm流程\n\n```\nsetImpl\n\tsetImplLocked\n\t\tnew Alarm\n\t\tsetImplLocked\n\t\t\tadjustDeliveryTimeBasedOnBucketLocked  /*Adjusts the alarm delivery time                                                   based on the current app standby bucket.*/\n\t\t\tinsertAndBatchAlarmLocked //将当前Alarm添加到合适的Batch中\n\t\t\t//check needRebatch\n\t\t\trebatchAllAlarmsLocked(false);//重置所有的Batch\n\t\t\trescheduleKernelAlarmsLocked(); //设置Alarm到kernel中\n\t\t\tupdateNextAlarmClockLocked(); //更新AlarmClock\n```\n\n大致一个Alarm的设置流程如上所示，具体的细节不在具体描述，可以参考文章开头的链接。\n\n这其中需要注意的点是在设置Alarm的过程中对变量whenElapsed，maxWhenElapsed的处理过程，以及对不同的Flag的处理，MTK的AlarmGroup机制原理是精准alarm的maxWhenElapsed也进行了调整。\n\n## 4 Alarm唤醒\n\n那么Alarm是怎么唤醒是怎么管理的？这里是通过在开机过程中启动一个AlarmThread来管理alarm对客户端的分发。\n\n常见的ACTION_TIME_CHANGED也是在这个线程中发送的。\n\n```\n【AlarmThread】\n\trun\t\n\t\tmInjector.waitForAlarm();\n\t\tif ((result & TIME_CHANGED_MASK) != 0)\n\t\tif (result != TIME_CHANGED_MASK) {\n\t\t\ttriggerAlarmsLocked                         //获取需要出发的AlarmList\n\t\t\tif (!hasWakeup && checkAllowNonWakeupDelayLocked(nowELAPSED)) { //非唤醒系统的Alarm判断是否可以进行延迟\n\t\t\t\tmPendingNonWakeupAlarms.addAll(triggerList);\n\t\t\t\tmNumDelayedAlarms += triggerList.size();\t\t\n\t\t\t\trescheduleKernelAlarmsLocked();\n\t\t\t\tupdateNextAlarmClockLocked();\n\t\t\tdeliverAlarmsLocked(triggerList, nowELAPSED); //分发Alarm\n\t\t\treorderAlarmsBasedOnStandbyBuckets(triggerPackages);\n\t\t\trescheduleKernelAlarmsLocked();   //重新设置kernel alarm\t\t \t\n\t\t\tupdateNextAlarmClockLocked();\t  //更新AlarmClock\n```\n\n从这里看核心的函数就是triggerAlarmsLocked， deliverAlarmsLocked，来分发alarm到客户端，当遇到具体的问题的时候在进行分析。\n\n\n\n## 5 总结\n\nAlarm机制的主要方式是通过一个线程不停的wait，在最近的定时到时唤醒继续判断是否需要分发alarm。","tags":["alarm","android"]}]