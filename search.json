[{"title":"cgroup","url":"/2019/10/04/cgroup/","content":"\n> 本文目的，仅用于自己梳理cgroup学习过程中整理的网络资料笔记，内容均来自网络。\n>\n> https://www.kernel.org/doc/Documentation/cgroup-v1/cgroups.txt\n>\n> https://mp.weixin.qq.com/s?src=11&timestamp=1570251437&ver=1893&signature=FIRTH40wSQODMcoT7tS82w12uiBs*eQlDbu*RmlS5n1dmQSQ4-pKUIKnVXoRR2hmSh1jl2CfGYsfHdoWqA*Ib2I-tBYtybLgp7H2xwzlnWK3R5on2TYWBXmuiyWksEtt&new=1\n>\n> https://www.yangcs.net/posts/understanding-cgroups-part-1-basics/\n\n从下面几个方面进行整理：\n\n- Cgroup简介\n- subsystem的attach规则\n- 实现原理\n\n## 1 Cgroup简介\n\nCgroup（Control Groups）是这样一种机制：它以分组的形式对进程使用系统资源的行为进行管理和控制。也就是说，用户通过cgroup对所有进程进行分组，再对该分组整体进行资源的分配和控制。\n\n系统内所有的进程组形成一颗具有层次等级（hierarchy）关系的进程组树。如下图\n\n![](1.jpg)\n\n- 同一个进程可能处于多个进程组中，但是必须是位于不同的层级中\n- 子进程在创建初期与父进程位于同一个进程组中\n\n\n\n**subsystem**\n\n​\t子系统是cgroup对进程组进行资源控制的具体行为.\n\n> 1. cpu子系统：该子系统为每个进程组设置一个使用CPU的权重值，以此来管理进程对cpu的访问。\n>\n> 2. cpuset子系统：对于多核cpu，该子系统可以设置进程组只能在指定的核上运行，并且还可以设置进程组在指定的内存节点上申请内存。\n>\n> 3. cpuacct子系统：该子系统只用于生成当前进程组内的进程对cpu的使用报告。\n>\n> 4. memory子系统：该子系统提供了以页面为单位对内存的访问，比如对进程组设置内存使用上限等，同时可以生成内存资源报告\n>\n> 5. blkio子系统：该子系统用于限制每个块设备的输入输出。首先，与CPU子系统类似，该系统通过为每个进程组设置权重来控制块设备对其的I/O时间；其次，该子系统也可以限制进程组的I/O带宽以及IOPS。\n>\n> 6. devices子系统：通过该子系统可以限制进程组对设备的访问，即该允许或禁止进程组对某设备的访问。\n>\n> 7. freezer子系统：该子系统可以使得进程组中的所有进程挂起。\n>\n> 8. net-cls子系统：该子系统提供对网络带宽的访问限制，比如对发送带宽和接收带宽进程限制\n\n子系统与cgroup的关系\n\n![](1.1.jpg)\n\n由图可以看出，cgroup在用户态提供统一的用户接口，而每个子系统对资源的控制功能则通过其钩子函数实现。这样使得cgroup在上层是一个统一的框架，而下层则可以实现多种资源的控制。每个子系统的钩子函数如下:\n\n![](1.2.jpg)\n\n**文件系统**\n\ncgroup在Linux内核中是以文件系统的形式存在的，不过cgroup对应的这种文件系统与proc文件系统类似，都是只存在于内存中的“虚拟”文件系统。既然如此，就可以通过mount命令创建一个cgroup实例。\n\n```\n$ sudo mount -t cgroup -o memory memory_cgroup /dev/cgroup/\n```\n\n即在/dev/cgroup/下创建了一个memory子系统。接下来就可以通过：\n\n```\n$ cat /proc/filesystems | grep cgroup\n```\n\n可看到系统有了cgroup类型的文件系统。\n当创建了一个cgroup实例后，对应的挂载点下会有一些文件，这些文件是用户与cgroup进行交互的接口。由于cgroup位于VFS层之下，因此用户可以通过统一的文件操作接口去读取或设置子系统的参数，当然也可以直接使用echo或者cat等命令。\n\n**cpu子系统**\n\ncpu子系统主要分布在内核的调度系统中，通过该子系统中的cpu.shares文件可对进程组设置权重。\n根据CFS的原理，一个进程的权重越大，那么它的被调度的可能性就越大。那么进程组的权重如何在CFS中体现？CFS将进程和进程组视为同一个调度体，并用sched_entity结构来表示，每个结构中包含该调度体的权重以及虚拟运行时间等。\n因此，用户可通过CPU子系统中的cpu.shares文件来控制进程组对CPU的使用。\n\n**cpuset子系统**\n\n​\t通过cpuset子系统中的cpuset.cpus和cpuset.mems可对进程组设定可访问的CPU和内存节点。内核使用cpuset结构来描述cpuset子系统的属性信息，其中该结构中的cpus_allowed和mems_allowed两个字段分别保存上述两个文件的值。同时，进程描述符中也有cpus_allowed和mems_allowed两个字段，其值与cpuset结构保持同步。\n\n​\tcpuset限制进程所能访问的CPU主要通过两方面。首先体现在进程的创建，如果父进程新建子进程时没有指定CLONE_STOPPED标志，则父进程将调用wake_up_new_task()将子进程状态设置为TASK_RUNNING，并将其加入就绪队列。为子进程选择就绪队列的具体工作则由select_task_rq()完成，其内部实现将涉及CPU的检查操作，即在cpus_allowed所指定的cpu范围内为当前进程分配CPU。\n\n​\t其次，当调度器在调度一个进程时，也要通过select_task_rq()进行同样的对比选择。这样就可以保证cgroup实例中的进程只在cpus_allowed所限定的cpu中运行。\n\n​\tcpuset进程所能访问内存节点的限制表现在物理内存的分配过程中。Linux内核将物理内存在逻辑上分为**node、zone和page**，内核通过alloc_pages()来实现物理内存的分配工作。alloc_pages()的主要工作是在所有物理内存中选择node，再在当前node中选择zone，最终在zone中分配一个物理页框。其中，在选择node的过程中会进行mems_allowed的判断过程。\n\n**memory子系统**\n\n\tcgroup对内存的控制通过memory子系统完成，其控制作用主要体现在对内存使用量的限制，同时为当前cgroup生成一份内存使用情况报告。\n\n​\t在具体实现的过程中，cgroup通过内核中的resource counter机制实现内存的限制。resource counter相当于一个通用的资源计数器，在内核中通过res_counter结构来描述。该结构可用于记录某类资源的当前使用量、最大使用量以及上限等信息。\n\n​\t内核对res_counter进行操作时有三个基本函数：res_counter_init()对res_counter进行初始化；当分配资源时，res_counter_charge()记录资源的使用量，并且该函数还会检查使用量是否超过了上限，并且记录当前资源使用量的最大值；当资源被释放时，res_counter_uncharge()则减少该资源的使用量。\n\n​\tcgroup对内存资源的限制主要是**将上述三个函数分布到内存的分配单元**中，比如，系统发生**缺页异常**时，由于**页表项未分配而申请内存时**，由于**页缓存而分配内存**等。\n\n**blkio子系统**\n\n​\tCgroup中通过blkio子系统完成对块设备I/O的控制。具体的控制主要通过**blkio.weight**文件在用户态设定当前进程组访问块**I/O的权重**，也就是控制进程组占有**I/O的时间**。\n\n​\tblkio子系统对块I/O的控制代码主要分布在I/O调度算法中，目前内核中默认的调度算法为**CFQ（完全公平队列）**，该算法与进程调度算法CFS比较类似。\n\n### 1.1 如何查看当前系统支持哪些subsystem\n\n> 以下内容来自：https://segmentfault.com/a/1190000006917884\n\n以下是手机中cat /proc/cgroups节点的输出信息\n\n```\n#subsys_name    hierarchy       num_cgroups     enabled\ncpuset              5                7             1\ncpu                 4                1             1\ncpuacct             1               188            1\nschedtune           3                5             1\nmemory              2                3             1\nfreezer             0                1             1\n```\n\nsubsys_name:子系统的名字\n\nhierarchy: 层级的ID\n\nnum_cgroups：层级中有的cgroup节点数量\n\nenabled: 是否使能\n\n### 1.2 查看进程的cgroup情况\n\n```\n2|XXX:/proc/4655 # cat cgroup\n6:name=none:/\n5:cpuset:/background\n4:cpu:/\n3:schedtune:/background\n2:memory:/\n1:cpuacct:/uid_1000/pid_4655\n```\n\n### 1.3 cgroup的挂载\n\n~~~\n# 挂载memory子系统到/dev/cgroup\nsudo mount -t cgroup -o memory memory_cgroup /dev/cgroup/\n\n# 挂载所有子系统到/dev/all\nsudo mount -t cgroup all /dev/all\n\n# 挂载一个cgroup树，不关联任何子系统\nsudo mount -t cgroup -o none,name=none none /dev/none\n\n~~~\n\n**注意**：\n\n- 第一次挂载一颗和指定subsystem关联的cgroup树时，会创建一颗新的cgroup树，当再一次用**同样的参数挂载时**，会重用现有的cgroup树，**也即两个挂载点看到的内容是一样的。**\n- **挂载一颗cgroup树时，可以指定多个subsystem与之关联，但一个subsystem只能关联到一颗cgroup树**，一旦关联并在这颗树上创建了子cgroup，subsystems和这棵cgroup树就成了一个整体，不能再重新组合。\n- **可以创建任意多个不和任何subsystem关联的cgroup树，name是这棵树的唯一标记，当name指定的是一个新的名字时，将创建一颗新的cgroup树，**但如果内核中已经存在一颗一样name的cgroup树，那么将mount已存在的这颗cgroup树\n\n### 1.4 管理单位\n\n**cgroup.procs vs tasks的区别**： procs表示的是进程的ID， tasks表示的线程ID，\n\n更加tasks可以进行更加细粒度的控制。\n\n**但在cgroup V2以后，将不再支持该功能，只能以进程为单位来配置cgroup**\n\n### 1.5 cgroup清理release_agent\n\nhttps://segmentfault.com/a/1190000007241437\n\n## 2 规则\n\n> 以下内容来源：https://sexywp.com/whats-cgroups.htm\n\n![](2.1.jpg)\n\n一个层次结构，可以附着一个或者多个子系统（来源 RedHat）\n\n![](2.2.jpg)\n\n一个子系统不能附着第二个已经附着过子系统的层次结构\n\n![](2.3.jpg)\n\n一个任务不能是同一个层次结构下的不同控制组的成员\n\n![](2.4.jpg)\n\nfork 出来的进程严格继承父进程的控制组\n\n## 3 原理\n\nhttps://mp.weixin.qq.com/s?__biz=MzI3NzA5MzUxNA==&mid=407106165&idx=1&sn=394d236027c2475178018162f51fcc4a&scene=19#wechat_redirect\n\nhttps://www.cnblogs.com/yjf512/p/6003094.html\n\nhttps://www.cnblogs.com/muahao/p/10281139.html\n\n图片来自Linux内核之旅\n\n![](3.1.jpg)\n\n![](3.2.jpg)\n\n![](3.3.jpg)\n\n\n\n图片引用自美团（很好的解释了cgroup和css_set的多对多关系）\n\n![](3.4.jpg)\n\n\n\n## 4 使用\n\n### 4.1 限制cgroup内存使用\n\n> 参考\n>\n> https://segmentfault.com/a/1190000008125359\n\n在Android中有会用到cgroup来限制内存的使用挂载为memcg\n\n**目的**： 限制一组进程的内存用量及内存使用情况控制。\n\n**功能**\t\n\n- 限制cgroup中所有进程使用内存的总量\n- 限制cgroup中所有进程能够使用的物理内存和交换空间**CONFIG_MEMCG_SWAP**总量\n- 限制cgroup中所有进的使用的内核内存总量及其他内核资源**CONFIG_MEMCG_KMEM**\n\n**内核配置**\n\n- memory subsystem消耗系统资源，可以单独配置关闭该子系统。cgroup_disable=memory\n- CONFIG_MEMCG_SWAP, CONFIG_MEMCG_KMEM\n\n> CONFIG_MEMCG_SWAP\n>\n> 给 Memory Resource Controller 添加对swap的管理功能.这样就可以针对每个cgroup限定其使用的mem+swap总量.如果关闭此选项, memory resource controller 将仅能限制mem的使用量,而无法对swap进行控制(进程有可能耗尽swap).开启此功能会对性能有不利影响,并且为了追踪swap的使用也会消耗更多的内存(如果swap的页面大小是4KB,那么每1GB的swap需要额外消耗512KB内存),所以在内存较小的系统上不建议开启.\n>\n> CONFIG_MEMCG_KMEM\n>\n> 为 Memory Resource Controller 添加对内核对象所占用内存的管理功能.和标准的 Memory Resource Controller 对内存的控制不一样之处在于:这些内核对象所占用的内存是基于每个内存页的,并且可以被swap到硬盘.使用这个功能可以确保cgroup中的进程不会单独耗尽所有内核资源\n\n**配置节点参数含义**\n\n```\n cgroup.event_control       #用于eventfd的接口\n memory.usage_in_bytes      #显示当前已用的内存\n memory.limit_in_bytes      #设置/显示当前限制的内存额度\n memory.failcnt             #显示内存使用量达到限制值的次数\n memory.max_usage_in_bytes  #历史内存最大使用量\n memory.soft_limit_in_bytes #设置/显示当前限制的内存软额度\n memory.stat                #显示当前cgroup的内存使用情况\n memory.use_hierarchy       #设置/显示是否将子cgroup的内存使用情况统计到当前cgroup里面\n memory.force_empty         #触发系统立即尽可能的回收当前cgroup中可以回收的内存\n memory.pressure_level      #设置内存压力的通知事件，配合cgroup.event_control一起使用\n memory.swappiness          #设置和显示当前的swappiness\n memory.move_charge_at_immigrate #设置当进程移动到其他cgroup中时，它所占用的内存是否也随着移动过去\n memory.oom_control         #设置/显示oom controls相关的配置\n memory.numa_stat           #显示numa相关的内存\n```\n\n **拓展阅读：**\n\n（[Android中基于CGroup的memory子系统HAL层分析-lmkd](https://www.cnblogs.com/arnoldlu/p/6221609.html)）\n\nhttps://www.cnblogs.com/arnoldlu/p/6221609.html \n\n### 4.2 限制cpu的使用\n\ncpu相关的限制子系统有cpu, cpuset, cpuacct\n\ncpu子系统控制节点\n\n- cpu.cfs_period_us，配置时间的周期长度（us）\n\n- cpu.cfs_quota_us， 配置周期长度内能够使用cpu时间数（us）\n- cpu.shares， 设置cpu的相对值（默认1024）\n- cpu.stat, 统计数据 nr_periods，过去了多少个周期； nr_throttled，有多少受到了限制； throttled_time， 被限制cpu持续了多长时间\n\n### 4.3 schedtune限制\n\nschedtune是ARM/Linaro为了EAS新增的一个子系统，主要用来控制进程调度选择CPU以及boost触发。\n\n#### 4.3.1 拓展知识进程调度\n\n**调度**：从进程的就绪队列中选择合适的进程分配cpu资源运行。\n\n**进程分类**：\n\n- CPU消耗型\n- IO消耗型\n\n**进程优先级**：（比如根据进程的优先级进行调度，优先级高的先运行）\n\n![](4.1.jpg)\n\n- 静态优先级： 不会时间而改变，内核也不会修改，只能通过系统调用改变nice值的方法区修改。优先级映射公式： `static_prio = MAX_RT_PRIO + nice + 20`，其中MAX_RT_PRIO = 100，那么取值区间为**[100, 139]**；对应普通进程；\n- 实时优先级：只对实时进程有意义，取值区间为[0, MAX_RT_PRIO -1]，其中MAX_RT_PRIO = 100，那么取值区间为**[0, 99]**；对应实时进程；\n- 动态优先级： 调度程序通过增加或减少进程静态优先级的值，来达到奖励IO消耗型或惩罚cpu消耗型的进程，调整后的进程称为动态优先级。区间范围[0, MX_PRIO-1]，其中MX_PRIO = 140，那么取值区间为**[0,139]**；\n\nnice∈[-20, 19]，可通过adb直接修改某个进程的nice值： `renice prio pid`\n\n**时间片**：\n\n​\t进程在被抢占和调度前所能持续运行的时间。\n\n​\t早期的Linux内核采用固定的时间片，现在的CFS调度器采用根据进程权重来分配cpu时间（权重与优先级有关）\n\n**调度算法**\n\n- 多级反馈队列调度算法\n\n> 1 根据优先级划分不同的队列\n>\n> 2 进程A优先级大于进程B优先级，则调度器选择A\n>\n> 3 如果A与B优先级一样，且在同一个队列，则使用轮转调度算法\n>\n> 4 新进程放入最高优先级队列\n>\n> 5 当一个进程吃满了时间片，说明是一个cpu消耗型，那么需要将此进程优先级降一级，迁移到低一级的队列里。\n>\n> 6 如果进程在时间片还没有结束前放弃cpu，说明是IO消耗型，保持原来的高优先级。\n\n缺点， 容易**产生饥饿**；有些进程会**欺骗调度器**；进程生命中有时候是cpu消耗型，有时候是io消耗型，很难区分。\n\n> 改进：\n>\n> ​\t（解决饥饿问题），每个时间周期S，把系统中所有进程优先级提到最高。\n>\n> ​\t（解决欺骗），当一个进程时间片用完，不管是否在末尾发生io请求，都把优先级降一级。\n\n\n\n- Linux O(n)调度算法\n\n全局就绪队列（链表），从就绪队列中选择最佳就绪进程（基于优先级）运行，赋予固定的时间片。使用完后选择下一个进程。\n\n- Linux O(1)调度算法\n\n基于多级反馈算法的变种。\n\n就绪队列分为两个优先级数组组成。活跃优先级数组，过期优先级数组。每个优先级数组包含140个优先级队列。\n\n当活跃数组的所有进程用完了时间片后，活跃数组和过期数组互换。\n\n- Linux CFS调度算法\n\n\n\n#### 4.3.2 schedtune\n\nschedtune，是ARM/Linaro为了EAS新增的一个子系统，主要用来控制进程调度选择CPU以及boost触发，连接在 Android 系统的 /dev/stune 层级结构上。\n\nEAS旨在以最小的功耗来获得最流畅的UI。这是其他外部组件（如schedtune）发挥作用的地方。\n\nSchedtune在每个cgroup中由两个可调参数定义，以确保更好地控制要完成的任务。它不仅可以控制多个CPU上任务的分散，还可以控制感知负载，以确保更快地完成对时间敏感的任务。这样，用户所使用的前台应用程序和服务将不会减慢并导致不必要的性能问题。\n\n**拓展阅读**\n\n[Android中关于cpu/cpuset/schedtune的应用](https://www.cnblogs.com/arnoldlu/p/6221608.html)\n\nhttps://zhuanlan.zhihu.com/p/60030839 EAS调度器缘起\n\nhttps://zhuanlan.zhihu.com/p/81668069 cgroup浅谈\n\nhttps://android.googlesource.com/kernel/common/+/android-4.14/Documentation/scheduler/sched-tune.txt\n\n**schedtune.prefer_idle**：调度cpu选择的倾向，更偏重性能还是功耗。\n\n> This is a flag which indicates to the scheduler that userspace would like\n> the scheduler to focus on energy or to focus on performance.\n>\n> A value of 0 (default) signals to the CFS scheduler that tasks in this group\n> can be placed according to the energy-aware wakeup strategy.\n> A value of 1 signals to the CFS scheduler that tasks in this group should be\n> placed to minimise wakeup latency.\n>\n> Android platforms typically use this flag for application tasks which the\n> user is currently interacting with\n\n**schedtune.capacity_min**：\n\n**schedtune.boost**：配置的值越大越偏重性能。使获得更多的cpu资源，更高的频率等。\n\n> ​\tThe boost value is expressed as an integer in the range [0..100].\n>\n> ​\tA value of 0 (default) configures the CFS scheduler for maximum energy\n> efficiency. This means that schedutil runs the tasks at the minimum OPP\n> required to satisfy their workload demand.\n>\n> ​\tA value of 100 configures scheduler for maximum performance, which translates to the selection of the maximum OPP on that CPU.\n>\n> ​\tThe range between 0 and 100 can be set to satisfy other scenarios suitably. For example to satisfy interactive response or depending on other system events\n> (battery level etc).\n>\n> ​\tThe overall design of the SchedTune module is built on top of \"Per-Entity Load\n> Tracking\" (PELT) signals and schedutil by introducing a bias on the OPP selection.\n>\n> ​\tEach time a task is allocated on a CPU, cpufreq is given the opportunity to tune\n> the operating frequency of that CPU to better match the workload demand. The\n> selection of the actual OPP being activated is influenced by the boost value\n> for the task CGroup.\n>\n> ​\tThis simple biasing approach leverages existing frameworks, which means minimal\n> modifications to the scheduler, and yet it allows to achieve a range of\n> different behaviours all from a single simple tunable knob.\n>\n> ​\tIn EAS schedulers, we use boosted task and CPU utilization for energy\n> calculation and energy-aware task placement.","tags":["cgroup","cpuset","linux"]},{"title":"AMS","url":"/2019/10/03/AMS/","content":"\n## 简介\n\n用一张图来表示AMS管理的内容，如下\n\n![](AMS.jpg)\n\n## 核心内容\n\n- AMS之进程启动\n\n- AMS之Activity启动\n- AMS之Service启动\n- AMS之Broadcast管理\n- AMS之ContentProvider管理\n\n## 进程启动\n\n    services\\core\\java\\com\\android\\server\\am\\ProcessList.java\n    /**\n     * @return {@code true} if process start is successful, false otherwise.\n     * @param app\n     * @param hostingRecord\n     * @param disableHiddenApiChecks\n     * @param abiOverride\n     */\n    @GuardedBy(\"mService\")\n    boolean startProcessLocked(ProcessRecord app, HostingRecord hostingRecord,\n            boolean disableHiddenApiChecks, boolean mountExtStorageFull,\n            String abiOverride) {\n核心API在Android Q中已经从ActivityManagerService中移动到ProcessList.java中，当系统启动四大组件的过程中如果组件所属的目标进程没有启动，那么就会先通过startProcessLocked启动进程，之后再继续四大组件的流程。\n\n**流程如下**\n\n~~~\nstartProcessLocked\n\tProcess.start\n\t\tZYGOTE_PROCESS.start\n\t\t\tfetchUsapPoolEnabledPropWithMinInterval\n\t\t\t\tinformZygotesOfUsapPoolStatus\n\t\t\tstartViaZygote\n\t\t\t\tzygoteSendArgsAndGetResult\n\t\t\t\t\t(usapool)attemptUsapSendArgsAndGetResult(使用usap填充进程池)\n\t\t\t\t\tattemptZygoteSendArgsAndGetResult\n\t\t\t\t\t\tzygoteWriter.write(msgStr);\n\t\t\t\t\t\tzygoteWriter.flush();\n\t\t\t\t\t\t......\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n----------------------------------------------------------------------------------------\nzygoteServer.runSelectLoop\n\tcommand = connection.processOneCommand\n\t\tZygote.forkAndSpecialize\n\t\t{以下内容运行在子进程中}\n\t\tzygoteServer.setForkChild();\n\t\thandleChildProc\n\t\t\tZygoteInit.zygoteInit\n\t\t\t\tRuntimeInit.applicationInit\n\t\t\t\treturn findStaticMain //找到ActivityThread的main方法，封装到对象中返回\n\t\t\t\t\tClass.forName(className, true, classLoader);\n\t\t\t\t\tm = cl.getMethod(\"main\", new Class[] { String[].class });\n\t\t\t\t\treturn new MethodAndArgsCaller(m, argv);\n\t\t......\t\t\n\tif (mIsForkChild) {return command;} //返回给ZygoteInit的main方法中\n\n在main方法中调用下面调用返回对象的run方法，从而执行了ActivityThread的main函数。\nif (caller != null) { caller.run();}\n~~~\n\n这里采用的方式是将ActivityThread的main方法找到后封装到对象返回给zygoteinit的main方法直接调用。在Android 8.0之前还是采用的直接在找到了ActivityThread的main方法后抛出异常在zygoteinit.main方法中捕获异常进而调用ActivityThread的main方法。\n\n为什么Android8.1之后抛弃了原来的实现方式而改用直接return的方式？个人猜测可能是便于理解吧，也有可能是效率更高，但是从google的提交信息中感觉像是提高code的稳定性和健壮性。\n\ngoogle提交信息如下\n\n[https://android-review.googlesource.com/c/platform/frameworks/base/+/484646](https://android.googlesource.com/platform/frameworks/base/+/bf99d06003e76469a99269816babe16a22d83b89^!/#F5)\n\n~~~\nZygote: Improve logging and error handling during connections.\n\nBefore this change, we were throwing a checked exception on success\nand returning on failure. This made it hard to figure out where / when\nsomething was going wrong. This change switches things around to throw\na RuntimeException when something goes wrong and to return a Runnable\non success. This lets us make stronger assertions in both the parent\nand the child process about their state and expected return values.\n\nThis change also upgrades the severity of several errors that we would\nearlier just ignore. We will now reject the command and terminate the\nconnection to the client when we encounter these errors such as:\n\n- Malformed arguments\n- Any ZygoteSecurityException, such as thown thrown by\n  applyUidSecurityPolicy and applyInvokeWithSecurityPolicy.\n- Any error in setting up pipes etc. to facilitate communication\n  with child processes.\n\nBug: 13618569\nTest: Manual\nChange-Id: Id931d44135ae2e4ede1bbac6a4b187f6c139e1fd\n~~~\n\n\n\n## Activity启动\n\n流程如下：\n\n~~~\nContextImpl.startActivity\n\tmMainThread.getInstrumentation().execStartActivity\n\t\tActivityTaskManager.getService().startActivityAsUser\n\t\t......\n\nActivityTaskManagerService.startActivityAsUser\n\tgetActivityStartController().obtainStarter(intent, \"startActivityAsUser\").\n\t\tmFactory.obtain().setIntent(intent).setReason(reason);@ActivityStartController\n\t\t通过工厂构造了一个ActivityStarter对象\n\nActivityStarter.execute\n\tstartActivity\n\t\tstartActivity{new ActivityRecord等}\n\t\t\tstartActivity\n\t\t\t\tstartActivityUnchecked\n\t\t\t\t\t mTargetStack.startActivityLocked\n\t\t\t\t\t \tmaybe: showStartingWindow\n\t\t\t\t\t resumeFocusedStacksTopActivities\n\t\t\t\t\t \tresumeTopActivityUncheckedLocked\n\t\t\t\t\t \t\tresumeTopActivityInnerLocked\n\t\t\t\t\t \t\t\tonResumeActivity(如果满足条件直接onResumeActivity)\n\t\t\t\t\t \t\t\t...\n\t\t\t\t\t \t\t\tmStackSupervisor.startSpecificActivityLocked//准备启动新的进程\n\n\nvoid startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) {\n        // Is this activity's application already running?\n        final WindowProcessController wpc =\n                mService.getProcessController(r.processName, r.info.applicationInfo.uid);\n\n        boolean knownToBeDead = false;\n        if (wpc != null && wpc.hasThread()) {\n            try {\n                realStartActivityLocked(r, wpc, andResume, checkConfig);//直接realStart\n                return;\n            } catch (RemoteException e) {\n                Slog.w(TAG, \"Exception when starting activity \"\n                        + r.intent.getComponent().flattenToShortString(), e);\n            }\n\n            // If a dead object exception was thrown -- fall through to\n            // restart the application.\n            knownToBeDead = true;\n        }\n\n        // Suppress transition until the new activity becomes ready, otherwise the keyguard can\n        // appear for a short amount of time before the new process with the new activity had the\n        // ability to set its showWhenLocked flags.\n        if (getKeyguardController().isKeyguardLocked()) {\n            r.notifyUnknownVisibilityLaunched();\n        }\n\n        try {\n            if (Trace.isTagEnabled(TRACE_TAG_ACTIVITY_MANAGER)) {\n                Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, \"dispatchingStartProcess:\"\n                        + r.processName);\n            }\n            // Post message to start process to avoid possible deadlock of calling into AMS with the\n            // ATMS lock held.\n            final Message msg = PooledLambda.obtainMessage(\n                    ActivityManagerInternal::startProcess, mService.mAmInternal, r.processName,\n                    r.info.applicationInfo, knownToBeDead, \"activity\", r.intent.getComponent());//这里交给了ActivityManagerService来处理\n            mService.mH.sendMessage(msg);\n        } finally {\n            Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);\n        }\n    }\n    \nActivityManagerserfice.startProcess\n\tstartProcessLocked\n\t\tmProcessList.startProcessLocked\n\t\t\t......\n\t\t\tProcess.start//接下来就和启动进程的流程一样了\n~~~\n\n上面只是简单的跟踪了一下流程，其中每一个函数涉及的知识点和内容都值得深入研究。\n\n## Service启动\n\n还是从一个Service的启动流程开始跟踪\n\n~~~\nstartService\n\tstartServiceCommon\n\t\tActivityManager.getService().startService\n\t\t\t.....跨进程binder调用\n(ActivityManagerService)\nstartService\n\tActiveServices.startServiceLocked\n\t\tstartServiceInnerLocked\n\t\t\tbringUpServiceLocked\n\t\t\t\trealStartServiceLocked\n\t\t\t\tor\n\t\t\t\tmAm.startProcessLocked\n\nrealStartServiceLocked\n\tapp.thread.scheduleCreateService //调用Service的onCreate\n\trequestServiceBindingsLocked \t//如果bindService会调用onBind\n\tsendServiceArgsLocked\t//调用onStartCommand\n~~~\n\n以下流程图参考\n\n> https://blog.csdn.net/Gaugamela/article/details/53611703\n\n![](Service.jpg)\n\nbindService:\n\n![](BindService.jpg)\n\n## ContentProvider管理\n\nhttp://gityuan.com/2016/07/30/content-provider/\n\n![](get_content_provider.jpg)\n\n- ContentProvider所属进程不存在\n\n![](content_provider_ipc.jpg)\n\n- ContentProvider进程启动，但是Provider未发布\n\n![](content_provider_ipc2.jpg)\n\n## Broadcast管理\n\n直接从AMS中跟踪\n\n~~~\nActivityManagerService.broadcastIntent\n\tbroadcastIntentLocked\n\t\tfinal BroadcastQueue queue = broadcastQueueForIntent(intent);\n        BroadcastRecord r = new BroadcastRecord\n      \tqueue.enqueueOrderedBroadcastLocked(r);\n        queue.scheduleBroadcastsLocked();\n        \tprocessNextBroadcast\n        \t\tprocessNextBroadcastLocked\n        \t\t\tprocessCurBroadcastLocked\n        \t\t\t...\n        \t\t\tstartProcessLocked\n        \t\t\tmPendingBroadcast = r;\n        \t\t\tmPendingBroadcastRecvIndex = recIdx;\n~~~\n\n广播处理\n\nhttp://gityuan.com/2016/06/04/broadcast-receiver/\n\n![](send_broadcast.jpg)\n\n## 资料推荐\n\nhttps://edwardlu0904.wordpress.com/2015/09/28/activitymanagerservice-part-1-structure-and-basic/\n\nhttps://edwardlu0904.wordpress.com/2015/10/01/activitymanagerservice-part-2-activity-start-procedure/\n\nhttps://blog.csdn.net/gaugamela/article/category/9267470/2\n\n以上三个链接的文章对AMS以及解释的比较完整了，1，2主要从宏观角度进行的分析，3链接中的系列文章非常详细的分析了AMS的源码，对深入理解AMS非常有帮助，值得反复阅读。目前对于自身来讲主要了解大致流程，在工作中遇到后根据问题再深入研究细节。","tags":["AMS","Android"]},{"title":"PMS","url":"/2019/09/22/PMS/","content":"\n## 1 简介\n\n![](PMS.jpg)\n\n","tags":["PMS"]},{"title":"Alarm简介","url":"/2019/09/22/Alarm简介/","content":"\n> 参考链接\n>\n> https://www.jianshu.com/p/32f438a0c239\n>\n> https://juejin.im/post/5c9095dff265da60c76cd327\n>\n> http://chendongqi.me/2017/03/06/AlarmGroup/    AlarmGroup机制\n\n\n\n## 1 介绍\n\nAlarmManager主要是用来设置一些定时执行的任务，比如启动Activity，发送广播等，还可以直接传入回调方法来定时执行，使用方法可以参考DeviceIdleController里面通过Alarm设置DOZE的状态机转化的过程。Android系统通过AlarmManagerService来为管理Alarm，AlarmManager来对外提供操作接口。\n\n**使用示例**\n\n```csharp\nAlarmManager aManager = (AlarmManager)context.getSystemService(Context.ALARM_SERVICE);\n        Intent in = new Intent();\n        in.setClass(context, RebootService.class);\n        PendingIntent pi = PendingIntent.getService(context, 0, in, 0);\n        aManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,24 * 60 * 60 * 1000, pi);\n```\n\n上面的例子是通过alarmmanager来执行一个服务，定时到了就会自动执行RebootService这个服务。\n\n![](1.png)\n\n![1569064049192](C:\\Users\\z\\AppData\\Roaming\\Typora\\typora-user-images\\1569064049192.png)\n\n上面是DeviceIdleController中对Alarm的使用方式，mDeepAlarmListener就是传入的回调，回调方法是onAlarm.\n\n<!-- more -->\n\n## 2  Alarm类型\n\n当然从介绍中知道了Alarm的左右以及部分使用方法，那么这里继续介绍一下设置Alarm时候的类型等。\n\n```\n/**\n * Alarm time in {@link System#currentTimeMillis System.currentTimeMillis()}\n * (wall clock time in UTC), which will wake up the device when\n * it goes off.\n */\npublic static final int RTC_WAKEUP = 0;\n/**\n * Alarm time in {@link System#currentTimeMillis System.currentTimeMillis()}\n * (wall clock time in UTC).  This alarm does not wake the\n * device up; if it goes off while the device is asleep, it will not be\n * delivered until the next time the device wakes up.\n */\npublic static final int RTC = 1;\n/**\n * Alarm time in {@link android.os.SystemClock#elapsedRealtime\n * SystemClock.elapsedRealtime()} (time since boot, including sleep),\n * which will wake up the device when it goes off.\n */\npublic static final int ELAPSED_REALTIME_WAKEUP = 2;\n/**\n * Alarm time in {@link android.os.SystemClock#elapsedRealtime\n * SystemClock.elapsedRealtime()} (time since boot, including sleep).\n * This alarm does not wake the device up; if it goes off while the device\n * is asleep, it will not be delivered until the next time the device\n * wakes up.\n */\npublic static final int ELAPSED_REALTIME = 3;\n/// M: added for powerOffAlarm feature @{\n/**\n * M: This alarm type is used to set an alarm that would be triggered if device\n * is in powerOff state. It is set to trigger POWER_OFF_ALARM_BUFFER_TIME ms earlier\n * than the actual alarm time so that phone is in wakeup state when actual alarm\n * triggers\n */\n/** @hide */\npublic static final int PRE_SCHEDULE_POWER_OFF_ALARM = 7;\n```\n\n```\n/** @hide */\n@UnsupportedAppUsage\npublic static final long WINDOW_EXACT = 0;\n/** @hide */\n@UnsupportedAppUsage\npublic static final long WINDOW_HEURISTIC = -1;\n\n/**\n * Flag for alarms: this is to be a stand-alone alarm, that should not be batched with\n * other alarms.\n * @hide\n */\n@UnsupportedAppUsage\npublic static final int FLAG_STANDALONE = 1<<0;\n\n/**\n * Flag for alarms: this alarm would like to wake the device even if it is idle.  This\n * is, for example, an alarm for an alarm clock.\n * @hide\n */\n@UnsupportedAppUsage\npublic static final int FLAG_WAKE_FROM_IDLE = 1<<1;\n\n/**\n * Flag for alarms: this alarm would like to still execute even if the device is\n * idle.  This won't bring the device out of idle, just allow this specific alarm to\n * run.  Note that this means the actual time this alarm goes off can be inconsistent\n * with the time of non-allow-while-idle alarms (it could go earlier than the time\n * requested by another alarm).\n *\n * @hide\n */\npublic static final int FLAG_ALLOW_WHILE_IDLE = 1<<2;\n\n/**\n * Flag for alarms: same as {@link #FLAG_ALLOW_WHILE_IDLE}, but doesn't have restrictions\n * on how frequently it can be scheduled.  Only available (and automatically applied) to\n * system alarms.\n *\n * @hide\n */\n@UnsupportedAppUsage\npublic static final int FLAG_ALLOW_WHILE_IDLE_UNRESTRICTED = 1<<3;\n\n/**\n * Flag for alarms: this alarm marks the point where we would like to come out of idle\n * mode.  It may be moved by the alarm manager to match the first wake-from-idle alarm.\n * Scheduling an alarm with this flag puts the alarm manager in to idle mode, where it\n * avoids scheduling any further alarms until the marker alarm is executed.\n * @hide\n */\n@UnsupportedAppUsage\npublic static final int FLAG_IDLE_UNTIL = 1<<4;\n```\n\n在使用Alarm的适合可以设置不同的Alarm类型，不同类型的Alarm唤醒的条件不同，比如是否能够在DOZE模式下唤醒，是否能够在sleep模式下唤醒系统等。\n\n## 3 设置Alarm流程\n\n```\nsetImpl\n\tsetImplLocked\n\t\tnew Alarm\n\t\tsetImplLocked\n\t\t\tadjustDeliveryTimeBasedOnBucketLocked  /*Adjusts the alarm delivery time                                                   based on the current app standby bucket.*/\n\t\t\tinsertAndBatchAlarmLocked //将当前Alarm添加到合适的Batch中\n\t\t\t//check needRebatch\n\t\t\trebatchAllAlarmsLocked(false);//重置所有的Batch\n\t\t\trescheduleKernelAlarmsLocked(); //设置Alarm到kernel中\n\t\t\tupdateNextAlarmClockLocked(); //更新AlarmClock\n```\n\n大致一个Alarm的设置流程如上所示，具体的细节不在具体描述，可以参考文章开头的链接。\n\n这其中需要注意的点是在设置Alarm的过程中对变量whenElapsed，maxWhenElapsed的处理过程，以及对不同的Flag的处理，MTK的AlarmGroup机制原理是精准alarm的maxWhenElapsed也进行了调整。\n\n## 4 Alarm唤醒\n\n那么Alarm是怎么唤醒是怎么管理的？这里是通过在开机过程中启动一个AlarmThread来管理alarm对客户端的分发。\n\n常见的ACTION_TIME_CHANGED也是在这个线程中发送的。\n\n```\n【AlarmThread】\n\trun\t\n\t\tmInjector.waitForAlarm();\n\t\tif ((result & TIME_CHANGED_MASK) != 0)\n\t\tif (result != TIME_CHANGED_MASK) {\n\t\t\ttriggerAlarmsLocked                         //获取需要出发的AlarmList\n\t\t\tif (!hasWakeup && checkAllowNonWakeupDelayLocked(nowELAPSED)) { //非唤醒系统的Alarm判断是否可以进行延迟\n\t\t\t\tmPendingNonWakeupAlarms.addAll(triggerList);\n\t\t\t\tmNumDelayedAlarms += triggerList.size();\t\t\n\t\t\t\trescheduleKernelAlarmsLocked();\n\t\t\t\tupdateNextAlarmClockLocked();\n\t\t\tdeliverAlarmsLocked(triggerList, nowELAPSED); //分发Alarm\n\t\t\treorderAlarmsBasedOnStandbyBuckets(triggerPackages);\n\t\t\trescheduleKernelAlarmsLocked();   //重新设置kernel alarm\t\t \t\n\t\t\tupdateNextAlarmClockLocked();\t  //更新AlarmClock\n```\n\n从这里看核心的函数就是triggerAlarmsLocked， deliverAlarmsLocked，来分发alarm到客户端，当遇到具体的问题的时候在进行分析。\n\n\n\n## 5 总结\n\nAlarm机制的主要方式是通过一个线程不停的wait，在最近的定时到时唤醒继续判断是否需要分发alarm。","tags":["alarm","android"]}]