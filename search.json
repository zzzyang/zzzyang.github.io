[{"title":"AMS","url":"/2019/10/03/AMS/","content":"\n## 简介\n\n用一张图来表示AMS管理的内容，如下\n\n![](AMS.jpg)\n\n## 核心内容\n\n- AMS之进程启动\n\n- AMS之Activity启动\n- AMS之Service启动\n- AMS之Broadcast管理\n- AMS之ContentProvider管理\n\n## 进程启动\n\n    services\\core\\java\\com\\android\\server\\am\\ProcessList.java\n    /**\n     * @return {@code true} if process start is successful, false otherwise.\n     * @param app\n     * @param hostingRecord\n     * @param disableHiddenApiChecks\n     * @param abiOverride\n     */\n    @GuardedBy(\"mService\")\n    boolean startProcessLocked(ProcessRecord app, HostingRecord hostingRecord,\n            boolean disableHiddenApiChecks, boolean mountExtStorageFull,\n            String abiOverride) {\n核心API在Android Q中已经从ActivityManagerService中移动到ProcessList.java中，当系统启动四大组件的过程中如果组件所属的目标进程没有启动，那么就会先通过startProcessLocked启动进程，之后再继续四大组件的流程。\n\n**流程如下**\n\n~~~\nstartProcessLocked\n\tProcess.start\n\t\tZYGOTE_PROCESS.start\n\t\t\tfetchUsapPoolEnabledPropWithMinInterval\n\t\t\t\tinformZygotesOfUsapPoolStatus\n\t\t\tstartViaZygote\n\t\t\t\tzygoteSendArgsAndGetResult\n\t\t\t\t\t(usapool)attemptUsapSendArgsAndGetResult(使用usap填充进程池)\n\t\t\t\t\tattemptZygoteSendArgsAndGetResult\n\t\t\t\t\t\tzygoteWriter.write(msgStr);\n\t\t\t\t\t\tzygoteWriter.flush();\n\t\t\t\t\t\t......\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n----------------------------------------------------------------------------------------\nzygoteServer.runSelectLoop\n\tcommand = connection.processOneCommand\n\t\tZygote.forkAndSpecialize\n\t\t{以下内容运行在子进程中}\n\t\tzygoteServer.setForkChild();\n\t\thandleChildProc\n\t\t\tZygoteInit.zygoteInit\n\t\t\t\tRuntimeInit.applicationInit\n\t\t\t\treturn findStaticMain //找到ActivityThread的main方法，封装到对象中返回\n\t\t\t\t\tClass.forName(className, true, classLoader);\n\t\t\t\t\tm = cl.getMethod(\"main\", new Class[] { String[].class });\n\t\t\t\t\treturn new MethodAndArgsCaller(m, argv);\n\t\t......\t\t\n\tif (mIsForkChild) {return command;} //返回给ZygoteInit的main方法中\n\n在main方法中调用下面调用返回对象的run方法，从而执行了ActivityThread的main函数。\nif (caller != null) { caller.run();}\n~~~\n\n这里采用的方式是将ActivityThread的main方法找到后封装到对象返回给zygoteinit的main方法直接调用。在Android 8.0之前还是采用的直接在找到了ActivityThread的main方法后抛出异常在zygoteinit.main方法中捕获异常进而调用ActivityThread的main方法。\n\n为什么Android8.1之后抛弃了原来的实现方式而改用直接return的方式？个人猜测可能是便于理解吧，也有可能是效率更高，但是从google的提交信息中感觉像是提高code的稳定性和健壮性。\n\ngoogle提交信息如下\n\n[https://android-review.googlesource.com/c/platform/frameworks/base/+/484646](https://android.googlesource.com/platform/frameworks/base/+/bf99d06003e76469a99269816babe16a22d83b89^!/#F5)\n\n~~~\nZygote: Improve logging and error handling during connections.\n\nBefore this change, we were throwing a checked exception on success\nand returning on failure. This made it hard to figure out where / when\nsomething was going wrong. This change switches things around to throw\na RuntimeException when something goes wrong and to return a Runnable\non success. This lets us make stronger assertions in both the parent\nand the child process about their state and expected return values.\n\nThis change also upgrades the severity of several errors that we would\nearlier just ignore. We will now reject the command and terminate the\nconnection to the client when we encounter these errors such as:\n\n- Malformed arguments\n- Any ZygoteSecurityException, such as thown thrown by\n  applyUidSecurityPolicy and applyInvokeWithSecurityPolicy.\n- Any error in setting up pipes etc. to facilitate communication\n  with child processes.\n\nBug: 13618569\nTest: Manual\nChange-Id: Id931d44135ae2e4ede1bbac6a4b187f6c139e1fd\n~~~\n\n\n\n## Activity启动\n\n流程如下：\n\n~~~\nContextImpl.startActivity\n\tmMainThread.getInstrumentation().execStartActivity\n\t\tActivityTaskManager.getService().startActivityAsUser\n\t\t......\n\nActivityTaskManagerService.startActivityAsUser\n\tgetActivityStartController().obtainStarter(intent, \"startActivityAsUser\").\n\t\tmFactory.obtain().setIntent(intent).setReason(reason);@ActivityStartController\n\t\t通过工厂构造了一个ActivityStarter对象\n\nActivityStarter.execute\n\tstartActivity\n\t\tstartActivity{new ActivityRecord等}\n\t\t\tstartActivity\n\t\t\t\tstartActivityUnchecked\n\t\t\t\t\t mTargetStack.startActivityLocked\n\t\t\t\t\t \tmaybe: showStartingWindow\n\t\t\t\t\t resumeFocusedStacksTopActivities\n\t\t\t\t\t \tresumeTopActivityUncheckedLocked\n\t\t\t\t\t \t\tresumeTopActivityInnerLocked\n\t\t\t\t\t \t\t\tonResumeActivity(如果满足条件直接onResumeActivity)\n\t\t\t\t\t \t\t\t...\n\t\t\t\t\t \t\t\tmStackSupervisor.startSpecificActivityLocked//准备启动新的进程\n\n\nvoid startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) {\n        // Is this activity's application already running?\n        final WindowProcessController wpc =\n                mService.getProcessController(r.processName, r.info.applicationInfo.uid);\n\n        boolean knownToBeDead = false;\n        if (wpc != null && wpc.hasThread()) {\n            try {\n                realStartActivityLocked(r, wpc, andResume, checkConfig);//直接realStart\n                return;\n            } catch (RemoteException e) {\n                Slog.w(TAG, \"Exception when starting activity \"\n                        + r.intent.getComponent().flattenToShortString(), e);\n            }\n\n            // If a dead object exception was thrown -- fall through to\n            // restart the application.\n            knownToBeDead = true;\n        }\n\n        // Suppress transition until the new activity becomes ready, otherwise the keyguard can\n        // appear for a short amount of time before the new process with the new activity had the\n        // ability to set its showWhenLocked flags.\n        if (getKeyguardController().isKeyguardLocked()) {\n            r.notifyUnknownVisibilityLaunched();\n        }\n\n        try {\n            if (Trace.isTagEnabled(TRACE_TAG_ACTIVITY_MANAGER)) {\n                Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, \"dispatchingStartProcess:\"\n                        + r.processName);\n            }\n            // Post message to start process to avoid possible deadlock of calling into AMS with the\n            // ATMS lock held.\n            final Message msg = PooledLambda.obtainMessage(\n                    ActivityManagerInternal::startProcess, mService.mAmInternal, r.processName,\n                    r.info.applicationInfo, knownToBeDead, \"activity\", r.intent.getComponent());//这里交给了ActivityManagerService来处理\n            mService.mH.sendMessage(msg);\n        } finally {\n            Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);\n        }\n    }\n    \nActivityManagerserfice.startProcess\n\tstartProcessLocked\n\t\tmProcessList.startProcessLocked\n\t\t\t......\n\t\t\tProcess.start//接下来就和启动进程的流程一样了\n~~~\n\n上面只是简单的跟踪了一下流程，其中每一个函数涉及的知识点和内容都值得深入研究。\n\n## Service启动\n\n还是从一个Service的启动流程开始跟踪\n\n~~~\nstartService\n\tstartServiceCommon\n\t\tActivityManager.getService().startService\n\t\t\t.....跨进程binder调用\n(ActivityManagerService)\nstartService\n\tActiveServices.startServiceLocked\n\t\tstartServiceInnerLocked\n\t\t\tbringUpServiceLocked\n\t\t\t\trealStartServiceLocked\n\t\t\t\tor\n\t\t\t\tmAm.startProcessLocked\n\nrealStartServiceLocked\n\tapp.thread.scheduleCreateService //调用Service的onCreate\n\trequestServiceBindingsLocked \t//如果bindService会调用onBind\n\tsendServiceArgsLocked\t//调用onStartCommand\n~~~\n\n以下流程图参考\n\n> https://blog.csdn.net/Gaugamela/article/details/53611703\n\n![](Service.jpg)\n\nbindService:\n\n![](BindService.jpg)\n\n## ContentProvider管理\n\nhttp://gityuan.com/2016/07/30/content-provider/\n\n![](get_content_provider.jpg)\n\n- ContentProvider所属进程不存在\n\n![](content_provider_ipc.jpg)\n\n- ContentProvider进程启动，但是Provider未发布\n\n![](content_provider_ipc2.jpg)\n\n## Broadcast管理\n\n直接从AMS中跟踪\n\n~~~\nActivityManagerService.broadcastIntent\n\tbroadcastIntentLocked\n\t\tfinal BroadcastQueue queue = broadcastQueueForIntent(intent);\n        BroadcastRecord r = new BroadcastRecord\n      \tqueue.enqueueOrderedBroadcastLocked(r);\n        queue.scheduleBroadcastsLocked();\n        \tprocessNextBroadcast\n        \t\tprocessNextBroadcastLocked\n        \t\t\tprocessCurBroadcastLocked\n        \t\t\t...\n        \t\t\tstartProcessLocked\n        \t\t\tmPendingBroadcast = r;\n        \t\t\tmPendingBroadcastRecvIndex = recIdx;\n~~~\n\n广播处理\n\nhttp://gityuan.com/2016/06/04/broadcast-receiver/\n\n![](send_broadcast.jpg)\n\n## 资料推荐\n\nhttps://edwardlu0904.wordpress.com/2015/09/28/activitymanagerservice-part-1-structure-and-basic/\n\nhttps://edwardlu0904.wordpress.com/2015/10/01/activitymanagerservice-part-2-activity-start-procedure/\n\nhttps://blog.csdn.net/gaugamela/article/category/9267470/2\n\n以上三个链接的文章对AMS以及解释的比较完整了，1，2主要从宏观角度进行的分析，3链接中的系列文章非常详细的分析了AMS的源码，对深入理解AMS非常有帮助，值得反复阅读。目前对于自身来讲主要了解大致流程，在工作中遇到后根据问题再深入研究细节。","tags":["-AMS -Android"]},{"title":"PMS","url":"/2019/09/22/PMS/","content":"\n## 1 简介\n\n![](PMS.jpg)\n\n","tags":["PMS"]},{"title":"Alarm简介","url":"/2019/09/22/Alarm简介/","content":"\n> 参考链接\n>\n> https://www.jianshu.com/p/32f438a0c239\n>\n> https://juejin.im/post/5c9095dff265da60c76cd327\n>\n> http://chendongqi.me/2017/03/06/AlarmGroup/    AlarmGroup机制\n\n\n\n## 1 介绍\n\nAlarmManager主要是用来设置一些定时执行的任务，比如启动Activity，发送广播等，还可以直接传入回调方法来定时执行，使用方法可以参考DeviceIdleController里面通过Alarm设置DOZE的状态机转化的过程。Android系统通过AlarmManagerService来为管理Alarm，AlarmManager来对外提供操作接口。\n\n**使用示例**\n\n```csharp\nAlarmManager aManager = (AlarmManager)context.getSystemService(Context.ALARM_SERVICE);\n        Intent in = new Intent();\n        in.setClass(context, RebootService.class);\n        PendingIntent pi = PendingIntent.getService(context, 0, in, 0);\n        aManager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP,24 * 60 * 60 * 1000, pi);\n```\n\n上面的例子是通过alarmmanager来执行一个服务，定时到了就会自动执行RebootService这个服务。\n\n![](1.png)\n\n![1569064049192](C:\\Users\\z\\AppData\\Roaming\\Typora\\typora-user-images\\1569064049192.png)\n\n上面是DeviceIdleController中对Alarm的使用方式，mDeepAlarmListener就是传入的回调，回调方法是onAlarm.\n\n<!-- more -->\n\n## 2  Alarm类型\n\n当然从介绍中知道了Alarm的左右以及部分使用方法，那么这里继续介绍一下设置Alarm时候的类型等。\n\n```\n/**\n * Alarm time in {@link System#currentTimeMillis System.currentTimeMillis()}\n * (wall clock time in UTC), which will wake up the device when\n * it goes off.\n */\npublic static final int RTC_WAKEUP = 0;\n/**\n * Alarm time in {@link System#currentTimeMillis System.currentTimeMillis()}\n * (wall clock time in UTC).  This alarm does not wake the\n * device up; if it goes off while the device is asleep, it will not be\n * delivered until the next time the device wakes up.\n */\npublic static final int RTC = 1;\n/**\n * Alarm time in {@link android.os.SystemClock#elapsedRealtime\n * SystemClock.elapsedRealtime()} (time since boot, including sleep),\n * which will wake up the device when it goes off.\n */\npublic static final int ELAPSED_REALTIME_WAKEUP = 2;\n/**\n * Alarm time in {@link android.os.SystemClock#elapsedRealtime\n * SystemClock.elapsedRealtime()} (time since boot, including sleep).\n * This alarm does not wake the device up; if it goes off while the device\n * is asleep, it will not be delivered until the next time the device\n * wakes up.\n */\npublic static final int ELAPSED_REALTIME = 3;\n/// M: added for powerOffAlarm feature @{\n/**\n * M: This alarm type is used to set an alarm that would be triggered if device\n * is in powerOff state. It is set to trigger POWER_OFF_ALARM_BUFFER_TIME ms earlier\n * than the actual alarm time so that phone is in wakeup state when actual alarm\n * triggers\n */\n/** @hide */\npublic static final int PRE_SCHEDULE_POWER_OFF_ALARM = 7;\n```\n\n```\n/** @hide */\n@UnsupportedAppUsage\npublic static final long WINDOW_EXACT = 0;\n/** @hide */\n@UnsupportedAppUsage\npublic static final long WINDOW_HEURISTIC = -1;\n\n/**\n * Flag for alarms: this is to be a stand-alone alarm, that should not be batched with\n * other alarms.\n * @hide\n */\n@UnsupportedAppUsage\npublic static final int FLAG_STANDALONE = 1<<0;\n\n/**\n * Flag for alarms: this alarm would like to wake the device even if it is idle.  This\n * is, for example, an alarm for an alarm clock.\n * @hide\n */\n@UnsupportedAppUsage\npublic static final int FLAG_WAKE_FROM_IDLE = 1<<1;\n\n/**\n * Flag for alarms: this alarm would like to still execute even if the device is\n * idle.  This won't bring the device out of idle, just allow this specific alarm to\n * run.  Note that this means the actual time this alarm goes off can be inconsistent\n * with the time of non-allow-while-idle alarms (it could go earlier than the time\n * requested by another alarm).\n *\n * @hide\n */\npublic static final int FLAG_ALLOW_WHILE_IDLE = 1<<2;\n\n/**\n * Flag for alarms: same as {@link #FLAG_ALLOW_WHILE_IDLE}, but doesn't have restrictions\n * on how frequently it can be scheduled.  Only available (and automatically applied) to\n * system alarms.\n *\n * @hide\n */\n@UnsupportedAppUsage\npublic static final int FLAG_ALLOW_WHILE_IDLE_UNRESTRICTED = 1<<3;\n\n/**\n * Flag for alarms: this alarm marks the point where we would like to come out of idle\n * mode.  It may be moved by the alarm manager to match the first wake-from-idle alarm.\n * Scheduling an alarm with this flag puts the alarm manager in to idle mode, where it\n * avoids scheduling any further alarms until the marker alarm is executed.\n * @hide\n */\n@UnsupportedAppUsage\npublic static final int FLAG_IDLE_UNTIL = 1<<4;\n```\n\n在使用Alarm的适合可以设置不同的Alarm类型，不同类型的Alarm唤醒的条件不同，比如是否能够在DOZE模式下唤醒，是否能够在sleep模式下唤醒系统等。\n\n## 3 设置Alarm流程\n\n```\nsetImpl\n\tsetImplLocked\n\t\tnew Alarm\n\t\tsetImplLocked\n\t\t\tadjustDeliveryTimeBasedOnBucketLocked  /*Adjusts the alarm delivery time                                                   based on the current app standby bucket.*/\n\t\t\tinsertAndBatchAlarmLocked //将当前Alarm添加到合适的Batch中\n\t\t\t//check needRebatch\n\t\t\trebatchAllAlarmsLocked(false);//重置所有的Batch\n\t\t\trescheduleKernelAlarmsLocked(); //设置Alarm到kernel中\n\t\t\tupdateNextAlarmClockLocked(); //更新AlarmClock\n```\n\n大致一个Alarm的设置流程如上所示，具体的细节不在具体描述，可以参考文章开头的链接。\n\n这其中需要注意的点是在设置Alarm的过程中对变量whenElapsed，maxWhenElapsed的处理过程，以及对不同的Flag的处理，MTK的AlarmGroup机制原理是精准alarm的maxWhenElapsed也进行了调整。\n\n## 4 Alarm唤醒\n\n那么Alarm是怎么唤醒是怎么管理的？这里是通过在开机过程中启动一个AlarmThread来管理alarm对客户端的分发。\n\n常见的ACTION_TIME_CHANGED也是在这个线程中发送的。\n\n```\n【AlarmThread】\n\trun\t\n\t\tmInjector.waitForAlarm();\n\t\tif ((result & TIME_CHANGED_MASK) != 0)\n\t\tif (result != TIME_CHANGED_MASK) {\n\t\t\ttriggerAlarmsLocked                         //获取需要出发的AlarmList\n\t\t\tif (!hasWakeup && checkAllowNonWakeupDelayLocked(nowELAPSED)) { //非唤醒系统的Alarm判断是否可以进行延迟\n\t\t\t\tmPendingNonWakeupAlarms.addAll(triggerList);\n\t\t\t\tmNumDelayedAlarms += triggerList.size();\t\t\n\t\t\t\trescheduleKernelAlarmsLocked();\n\t\t\t\tupdateNextAlarmClockLocked();\n\t\t\tdeliverAlarmsLocked(triggerList, nowELAPSED); //分发Alarm\n\t\t\treorderAlarmsBasedOnStandbyBuckets(triggerPackages);\n\t\t\trescheduleKernelAlarmsLocked();   //重新设置kernel alarm\t\t \t\n\t\t\tupdateNextAlarmClockLocked();\t  //更新AlarmClock\n```\n\n从这里看核心的函数就是triggerAlarmsLocked， deliverAlarmsLocked，来分发alarm到客户端，当遇到具体的问题的时候在进行分析。\n\n\n\n## 5 总结\n\nAlarm机制的主要方式是通过一个线程不停的wait，在最近的定时到时唤醒继续判断是否需要分发alarm。","tags":["alarm","android"]}]